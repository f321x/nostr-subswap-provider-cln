import asyncio
import traceback

import attr
import json
import os
import math
from decimal import Decimal
from typing import Optional, Dict, Tuple, Union
import electrum_aionostr as aionostr
from electrum_ecc import ECPrivkey
from electrum_aionostr.util import to_nip19
from collections import defaultdict

from .bitcoin import opcodes, dust_threshold, construct_script, script_to_p2wsh, construct_witness
from .transaction import (PartialTxOutput, PartialTransaction, TxOutpoint,
                          OPPushDataGeneric, OPPushDataPubkey, PartialTxInput)
from .utils import OldTaskGroup, now, BelowDustLimit, TxBroadcastError
from .bitcoin import DummyAddress
from .crypto import ripemd, sha256
from .lnutil import hex_to_bytes, REDEEM_AFTER_DOUBLE_SPENT_DELAY, bytes_to_hex
from .invoices import Invoice, HoldInvoice, InvoiceState
from .json_db import StoredObject, stored_in, JsonDB
from . import constants
from .constants import (MIN_LOCKTIME_DELTA, LOCKTIME_DELTA_REFUND, MAX_LOCKTIME_DELTA,
                       MIN_FINAL_CLTV_DELTA_FOR_CLIENT, CLAIM_FEE_SIZE, LOCKUP_FEE_SIZE,
                        MIN_FINAL_CLTV_DELTA_ACCEPTED, MIN_FINAL_CLTV_DELTA_FOR_INVOICE)
from .cln_chain import CLNChainWallet
from .cln_lightning import CLNLightning
from .plugin_config import PluginConfig
from .cln_logger import PluginLogger
from .chain_monitor import ChainMonitor


# REVERSE SWAPS:
#         - User generates preimage, RHASH. Sends RHASH to server.
#         - Server creates an LN invoice for RHASH.
#         - User pays LN invoice - except server needs to hold the HTLC as preimage is unknown.
#             - if the server requested a fee prepayment (using 'minerFeeInvoice'),
#               the server will have the preimage for that. The user will send HTLCs for both the main RHASH,
#               and for the fee prepayment. Once both MPP sets arrive at the server, the server will fulfill
#               the HTLCs for the fee prepayment (before creating the on-chain output).
#         - Server creates on-chain output locked to RHASH.
#         - User spends on-chain output, revealing preimage.
#         - Server fulfills HTLC using preimage.

# The script of the reverse swaps has one extra check in it to verify
# that the length of the preimage is 32. This is required because in
# the reverse swaps the preimage is generated by the user and to
# settle the hold invoice, you need a preimage with 32 bytes . If that
# check wasn't there the user could generate a preimage with a
# different length which would still allow for claiming the onchain
# coins but the invoice couldn't be settled

WITNESS_TEMPLATE_REVERSE_SWAP = [
     opcodes.OP_SIZE,
     OPPushDataGeneric(None),
     opcodes.OP_EQUAL,
     opcodes.OP_IF,
     opcodes.OP_HASH160,
     OPPushDataGeneric(lambda x: x == 20),
     opcodes.OP_EQUALVERIFY,
     OPPushDataPubkey,
     opcodes.OP_ELSE,
     opcodes.OP_DROP,
     OPPushDataGeneric(None),
     opcodes.OP_CHECKLOCKTIMEVERIFY,
     opcodes.OP_DROP,
     OPPushDataPubkey,
     opcodes.OP_ENDIF,
     opcodes.OP_CHECKSIG
 ]

@stored_in('submarine_swaps')
@attr.s
class SwapData(StoredObject):
    is_reverse = attr.ib(type=bool)  # for whoever is running code (PoV of client or server)
    locktime = attr.ib(type=int)
    onchain_amount = attr.ib(type=int)  # in sats
    lightning_amount = attr.ib(type=int)  # in sats
    redeem_script = attr.ib(type=str, converter=bytes_to_hex)
    preimage = attr.ib(type=Optional[str], converter=bytes_to_hex)
    prepay_hash = attr.ib(type=Optional[str], converter=bytes_to_hex)
    privkey = attr.ib(type=str, converter=bytes_to_hex)
    lockup_address = attr.ib(type=str)
    receive_address = attr.ib(type=str)
    funding_txid = attr.ib(type=Optional[str])
    spending_txid = attr.ib(type=Optional[str])
    is_redeemed = attr.ib(type=bool)

    _funding_prevout = None  # type: Optional[TxOutpoint]  # for RBF
    _payment_hash = None

    @property
    def payment_hash(self) -> bytes:
        return hex_to_bytes(self._payment_hash)


def create_claim_tx(
        *,
        txin: PartialTxInput,
        witness_script: Union[str, bytes],
        address: str,
        amount_sat: int,
        locktime: int,
) -> PartialTransaction:
    """Create tx to either claim successful reverse-swap,
    or to get refunded for timed-out forward-swap.
    """
    if isinstance(witness_script, str):
        witness_script = hex_to_bytes(witness_script)
    txin.script_sig = b''
    txin.witness_script = witness_script
    txout = PartialTxOutput.from_address_and_value(address, amount_sat)
    tx = PartialTransaction.from_io([txin], [txout], version=2, locktime=locktime)
    tx.set_rbf(True)
    return tx


class SwapManager:

    def __init__(self, *, wallet: CLNChainWallet, lnworker: CLNLightning,
                 db: JsonDB, plugin_config: PluginConfig, logger: PluginLogger, chain_monitor: ChainMonitor):
        self.logger = logger
        self.normal_fee = None
        self.lockup_fee = None
        self.claim_fee = None  # part of the boltz prococol, not used by Electrum
        self.percentage = None
        self._min_amount = None
        self._max_amount = None

        self.wallet = wallet
        self.lnworker = lnworker
        self.lnwatcher = chain_monitor
        self.db = db
        self.dummy_address = DummyAddress.SWAP
        self.config = plugin_config
        self.taskgroup = OldTaskGroup()

        self.swaps = self.db.get_dict('submarine_swaps')  # type: Dict[str, SwapData]
        self._swaps_by_funding_outpoint = {}  # type: Dict[TxOutpoint, SwapData]
        self._swaps_by_lockup_address = {}  # type: Dict[str, SwapData]
        for payment_hash_hex, swap in self.swaps.items():
            payment_hash = bytes.fromhex(payment_hash_hex)
            swap._payment_hash = payment_hash
            self._add_or_reindex_swap(swap)
            if not swap.is_reverse and not swap.is_redeemed:
                self.lnworker.register_hold_invoice_callback(payment_hash=payment_hash, callback=self.hold_invoice_callback)

        self.prepayments = {}  # type: Dict[bytes, bytes] # fee_rhash -> rhash
        for k, swap in self.swaps.items():
            if swap.prepay_hash is not None:
                self.prepayments[swap.prepay_hash] = bytes.fromhex(k)
        self.assert_constants()
        self.is_server = True  # this plugin is always a server
        self.use_nostr = True  # this plugin only uses nostr comm
        self.is_initialized = asyncio.Event()  # set once nostr is connected to relays

    # @log_exceptions
    async def run_nostr_server(self):
        while True:
            try:
                with NostrTransport(config=self.config, sm=self) as transport:
                    await transport.is_connected.wait()
                    self.logger.info(f'nostr is connected')
                    while True:
                        # todo: publish everytime fees have changed
                        self.server_update_pairs()
                        await transport.publish_offer(self)
                        if not self.is_initialized.is_set():  # if publish offer didn't set initialized we retry faster
                            await asyncio.sleep(10)
                            continue
                        await asyncio.sleep(600)
            except asyncio.TimeoutError:
                self.logger.warning(f"Nostr timeout, restarting Nostr module")
            await asyncio.sleep(15)

    async def main_loop(self):
        if self.is_initialized.is_set():
            raise Exception("swap manager main_loop called twice, already running")
        # readd all swaps to lnwatcher
        for k, swap in self.swaps.items():
            if swap.is_redeemed:
                continue
            self.add_lnwatcher_callback(swap)

        tasks = [self.pay_pending_ln_invoices(), self.run_nostr_server()]

        async with self.taskgroup as group:
            for task in tasks:
                await group.spawn(task)

    async def stop(self):
        self.logger.debug("SwapManager stop() called")
        await self.taskgroup.cancel_remaining()

    def assert_constants(self):
        assert MIN_LOCKTIME_DELTA <= LOCKTIME_DELTA_REFUND <= MAX_LOCKTIME_DELTA, \
            f"assert failed: {MIN_LOCKTIME_DELTA} <= {LOCKTIME_DELTA_REFUND} <= {MAX_LOCKTIME_DELTA}"
        assert MAX_LOCKTIME_DELTA < MIN_FINAL_CLTV_DELTA_ACCEPTED, \
            f"assert failed: {MAX_LOCKTIME_DELTA} < {MIN_FINAL_CLTV_DELTA_ACCEPTED}"
        assert MAX_LOCKTIME_DELTA < MIN_FINAL_CLTV_DELTA_FOR_INVOICE, \
            f"assert failed: {MAX_LOCKTIME_DELTA} < {MIN_FINAL_CLTV_DELTA_FOR_INVOICE}"
        assert MAX_LOCKTIME_DELTA < MIN_FINAL_CLTV_DELTA_FOR_CLIENT, \
            f"assert failed: {MAX_LOCKTIME_DELTA} < {MIN_FINAL_CLTV_DELTA_FOR_CLIENT}"

    async def pay_pending_ln_invoice(self, key):
        self.logger.debug(f'trying to pay invoice {key}')
        self.invoices_to_pay[key] = 1000000000000 # lock
        try:
            invoice = self.lnworker.get_invoice(key)
            success, log = await self.lnworker.pay_invoice(bolt11=invoice.lightning_invoice, attempts=10)
        except Exception as e:
            self.logger.info(f'exception paying {key}, will not retry')
            self.invoices_to_pay.pop(key, None)
            self.lnworker.delete_invoice(key)
            return
        if not success:
            self.logger.info(f'failed to pay pending invoice {key}: {log}, will retry in 10 minutes')
            self.invoices_to_pay[key] = now() + 600
        else:
            self.logger.info(f'paid invoice {key}')
            self.lnworker.delete_invoice(key)
            self.invoices_to_pay.pop(key, None)

    async def pay_pending_ln_invoices(self):
        self.invoices_to_pay = {}
        while True:
            await asyncio.sleep(5)
            for key, not_before in list(self.invoices_to_pay.items()):
                if now() < not_before:
                    continue
                await self.taskgroup.spawn(self.pay_pending_ln_invoice(key))

    def _fail_swap(self, swap: SwapData, reason: str):
        self.logger.info(f'failing swap {swap.payment_hash.hex()}: {reason}')
        if not swap.is_reverse and swap.payment_hash in self.lnworker._hold_invoice_callbacks:
            self.lnworker.unregister_hold_invoice_callback(swap.payment_hash)
            for payment_hash in [swap.payment_hash, swap.prepay_hash]:
                # prepay hash is probably already settled at this point
                invoice = self.lnworker.get_hold_invoice(payment_hash)
                if invoice:
                    invoice.cancel_all_htlcs()
                    self.lnworker.delete_hold_invoice(payment_hash)
                self.lnworker.delete_payment_info(payment_hash)
        self.lnwatcher.remove_callback(swap.lockup_address)
        if swap.funding_txid is None:
            self.swaps.pop(swap.payment_hash.hex())
        self.db.write()

    def _finish_normal_swap(self, swap: SwapData):
        self.logger.info(f'finishing normal swap {swap.payment_hash.hex()}')
        assert swap.preimage, f"Cannot settle without preimage: {swap.payment_hash.hex()}"
        hold_invoice = self.lnworker.get_hold_invoice(swap.payment_hash)
        hold_invoice.settle(swap.preimage)
        if not hold_invoice.funding_status == InvoiceState.SETTLED:
            self.logger.info(f'hold invoice settling failed: {swap.payment_hash.hex()}')
            return
        self.lnworker.delete_hold_invoice(swap.payment_hash)
        self.lnworker.delete_payment_info(swap.payment_hash)
        self.lnwatcher.remove_callback(swap.lockup_address)
        self.swaps.pop(swap.payment_hash.hex())
        self.db.write()

    # @log_exceptions
    async def _claim_swap(self, swap: SwapData) -> None:
        assert self.lnwatcher
        if not await self.lnwatcher.is_up_to_date():
            self.logger.warning('_claim_swap caled but core node not up to date, skipping')
            return
        current_height = await self.wallet.get_local_height()
        remaining_time = swap.locktime - current_height
        txos = await self.lnwatcher.get_addr_outputs(swap.lockup_address)

        self.logger.debug(f'_claim_swap lockup addr: {swap.lockup_address} found {len(txos)} txout spending to it')
        for txin in txos:
            if swap.is_reverse and txin.value_sats() < swap.onchain_amount:
                # amount too low, we must not reveal the preimage
                continue
            break
        else:
            # swap not funded.
            txin = None
            # if it is a normal swap, we might have double spent the funding tx
            # in that case we need to fail the HTLCs
            if remaining_time <= 0:
                self._fail_swap(swap, 'expired')

        if txin:
            self.logger.debug(f'claim_swap found funding tx {txin.prevout.txid.hex()}')
            # the swap is funded
            # note: swap.funding_txid can change due to RBF, it will get updated here:
            swap.funding_txid = txin.prevout.txid.hex()
            swap._funding_prevout = txin.prevout
            self._add_or_reindex_swap(swap)  # to update _swaps_by_funding_outpoint
            funding_height = await self.lnwatcher.get_tx_height(txin.prevout.txid.hex())
            spent_height = txin.spent_height
            should_bump_fee = False
            self.logger.debug(f"claim_swap: Swap funding output has been spent at height "
                              f"{spent_height} in tx {txin.spent_txid}")
            if spent_height is not None:
                swap.spending_txid = txin.spent_txid
                if spent_height > 0 and current_height - spent_height > REDEEM_AFTER_DOUBLE_SPENT_DELAY:
                        self.logger.info(f'stop watching swap {swap.lockup_address}')
                        self.lnwatcher.remove_callback(swap.lockup_address)
                        swap.is_redeemed = True

                    # if current_height - spent_height > REDEEM_AFTER_DOUBLE_SPENT_DELAY:
                # else:
                    # spending tx is in mempool
                    # pass
                # elif spent_height == TX_HEIGHT_LOCAL:
                #     if funding_height.conf > 0 or (swap.is_reverse and self.wallet.config.LIGHTNING_ALLOW_INSTANT_SWAPS):
                #         tx = self.lnwatcher.adb.get_transaction(txin.spent_txid)
                #         try:
                #             await self.network.broadcast_transaction(tx)
                #         except TxBroadcastError:
                #             self.logger.info(f'error broadcasting claim tx {txin.spent_txid}')
                #     elif funding_height.height == TX_HEIGHT_LOCAL:
                #         # the funding tx was double spent.
                #         # this will remove both funding and child (spending tx) from adb
                #         self.lnwatcher.adb.remove_transaction(swap.funding_txid)
                #         swap.funding_txid = None
                #         swap.spending_txid = None

            if not swap.is_reverse:
                if swap.preimage is None and spent_height is not None:
                    # extract the preimage, add it to lnwatcher
                    claim_tx = await self.lnwatcher.get_transaction(txin.spent_txid)
                    preimage = claim_tx.inputs()[0].witness_elements()[1]
                    self.logger.debug(f"claim swap extracted preimage: {preimage.hex()} for {swap.lockup_address}")
                    if sha256(preimage) == swap.payment_hash:
                        swap.preimage = preimage.hex()
                        self.logger.info(f'found preimage: {preimage.hex()}')
                        return self._finish_normal_swap(swap)
                        # note: we must check the payment secret before we broadcast the funding tx
                    else:
                        # this is our refund tx
                        if spent_height > 0:
                            self.logger.info(f'refund tx confirmed: {txin.spent_txid} {spent_height}')
                            return self._fail_swap(swap, 'refund tx confirmed')
                        else:
                            # claim_tx.add_info_from_wallet(self.wallet)
                            claim_tx_fee = claim_tx.get_fee()
                            recommended_fee = self.get_claim_fee()
                            if claim_tx_fee * 1.1 < recommended_fee:
                                should_bump_fee = True
                                self.logger.info(f'claim tx fee too low {claim_tx_fee} < {recommended_fee}. we will bump the fee')

                if remaining_time > 0:
                    # too early for refund
                    self.logger.debug(f'claim_swap: remaining time {remaining_time} for {swap.lockup_address},'
                                      f'too early for refund')
                    return

                if swap.preimage:
                    # we have been paid. do not try to get refund.
                    self.logger.debug(f"claim_swap: we have been paid for {swap.lockup_address}, "
                                      f"not trying to get refund")
                    return

            else:
                if swap.preimage is None:
                    swap.preimage = self.lnworker.get_preimage(swap.payment_hash)
                if swap.preimage is None:
                    if funding_height.conf <= 0:
                        return
                    key = swap.payment_hash.hex()
                    if remaining_time <= MIN_LOCKTIME_DELTA:
                        if key in self.invoices_to_pay:
                            # fixme: should consider cltv of ln payment
                            self.logger.info(f'locktime too close {key} {remaining_time}')
                            self.invoices_to_pay.pop(key, None)
                        return
                    if key not in self.invoices_to_pay:
                        self.invoices_to_pay[key] = 0
                    return

                # if self.network.config.TEST_SWAPSERVER_REFUND:
                    # for testing: do not create claim tx
                    # return

            if spent_height is not None and not should_bump_fee:
                return
            try:
                tx = self._create_and_sign_claim_tx(txin=txin, swap=swap)
            except BelowDustLimit:
                self.logger.info('utxo value below dust threshold')
                return
            self.logger.info(f'adding claim tx {tx.txid()}')
            # self.wallet.adb.add_transaction(tx)
            swap.spending_txid = tx.txid()
            if funding_height.conf > 0: # or (swap.is_reverse and self.wallet.config.LIGHTNING_ALLOW_INSTANT_SWAPS):
                try:
                    self.wallet.broadcast_transaction(tx)
                except TxBroadcastError:
                    self.logger.info(f'error broadcasting claim tx {txin.spent_txid}')

    def get_claim_fee(self):
        return self.get_fee(size_vb=CLAIM_FEE_SIZE)

    def get_fee(self, *, size_vb: int) -> int:
        # note: 'size' is in vbytes
        return self.wallet.get_chain_fee(size_vbyte=size_vb)

    def add_lnwatcher_callback(self, swap: SwapData) -> None:
        callback = lambda: self._claim_swap(swap)
        self.lnwatcher.add_callback(swap.lockup_address, callback)

    def hold_invoice_callback(self, payment_hash: bytes) -> None:
        key = payment_hash.hex()
        if key in self.swaps:
            swap = self.swaps[key]
            if swap.funding_txid is None:
                # password = self.wallet.get_unlocked_password()
                # for batch_rbf in [True, False]:
                tx = self.create_funding_tx(swap=swap, tx=None)
                # try:
                self.broadcast_funding_tx(swap, tx)
                # except TxBroadcastError:
                #     continue
                # break


    async def create_normal_swap(self, *, lightning_amount_sat: int, payment_hash: bytes, their_pubkey: bytes = None):
        """ server method """
        assert lightning_amount_sat
        locktime = await self.wallet.get_local_height() + LOCKTIME_DELTA_REFUND
        our_privkey = os.urandom(32)
        our_pubkey = ECPrivkey(our_privkey).get_public_key_bytes(compressed=True)
        onchain_amount_sat = self._get_recv_amount(lightning_amount_sat, is_reverse=True) # what the client is going to receive
        redeem_script = construct_script(
            WITNESS_TEMPLATE_REVERSE_SWAP,
            {1:32, 5:ripemd(payment_hash), 7:their_pubkey, 10:locktime, 13:our_pubkey}
        )
        swap, invoice, prepay_invoice = await self.add_normal_swap(
            redeem_script=redeem_script,
            locktime=locktime,
            onchain_amount_sat=onchain_amount_sat,
            lightning_amount_sat=lightning_amount_sat,
            payment_hash=payment_hash,
            our_privkey=our_privkey,
            prepay=True,
        )
        # callback will be triggered when the swap invoice is paid to broadcast the funding tx
        self.lnworker.register_hold_invoice_callback(payment_hash=payment_hash, callback=self.hold_invoice_callback)
        return swap, invoice, prepay_invoice


    async def add_normal_swap(
            self, *,
            redeem_script: bytes,
            locktime: int,  # onchain
            onchain_amount_sat: int,
            lightning_amount_sat: int,
            payment_hash: bytes,
            our_privkey: bytes,
            prepay: bool,
            min_final_cltv_expiry_delta: Optional[int] = None,
    ) -> Tuple[SwapData, str, Optional[str]]:
        """creates a hold invoice"""
        if prepay:
            prepay_amount_sat = self.get_claim_fee() * 2
            invoice_amount_sat = lightning_amount_sat - prepay_amount_sat
        else:
            invoice_amount_sat = lightning_amount_sat

        invoice = self.lnworker.b11invoice_from_hash(
            payment_hash=payment_hash,
            amount_msat=invoice_amount_sat * 1000,
            message='Submarine swap',
            expiry=300,
            fallback_address=None,
            min_final_cltv_expiry_delta=min_final_cltv_expiry_delta,
        )
        # self.lnworker.add_payment_info_for_hold_invoice(payment_hash, invoice_amount_sat)

        if prepay:
            prepay_hash = self.lnworker.create_payment_info(amount_msat=prepay_amount_sat*1000)
            prepay_invoice = self.lnworker.b11invoice_from_hash(
                payment_hash=prepay_hash,
                amount_msat=prepay_amount_sat * 1000,
                message='Submarine swap mining fees',
                expiry=300,
                fallback_address=None,
                min_final_cltv_expiry_delta=min_final_cltv_expiry_delta,
            )

            self.lnworker.bundle_payments(swap_invoice=invoice, prepay_invoice=prepay_invoice)
            self.prepayments[prepay_hash] = payment_hash
        else:
            prepay_invoice = None
            prepay_hash = None

        lockup_address = script_to_p2wsh(redeem_script, net=self.config.network)
        receive_address = self.wallet.get_receiving_address()
        swap = SwapData(
            redeem_script=redeem_script.hex(),
            locktime = locktime,
            privkey = our_privkey.hex(),
            preimage = None,
            prepay_hash = prepay_hash.hex(),
            lockup_address = lockup_address,
            onchain_amount = onchain_amount_sat,
            receive_address = receive_address,
            lightning_amount = lightning_amount_sat,
            is_reverse = False,
            is_redeemed = False,
            funding_txid = None,
            spending_txid = None,
        )
        swap._payment_hash = payment_hash
        self._add_or_reindex_swap(swap)
        await self.lnwatcher.register_address(lockup_address)  # adds the address to the bcore wallet
        self.add_lnwatcher_callback(swap)
        return swap, invoice.bolt11, prepay_invoice.bolt11

    async def create_reverse_swap(self, *, lightning_amount_sat: int, their_pubkey: bytes) -> SwapData:
        """ server method. """
        assert lightning_amount_sat is not None
        locktime = await self.wallet.get_local_height() + LOCKTIME_DELTA_REFUND
        privkey = os.urandom(32)
        our_pubkey = ECPrivkey(privkey).get_public_key_bytes(compressed=True)
        onchain_amount_sat = self._get_send_amount(lightning_amount_sat, is_reverse=False)
        preimage = os.urandom(32)
        payment_hash = sha256(preimage)
        redeem_script = construct_script(
            WITNESS_TEMPLATE_REVERSE_SWAP,
            {1:32, 5:ripemd(payment_hash), 7:our_pubkey, 10:locktime, 13:their_pubkey}
        )
        swap = await self.add_reverse_swap(
            redeem_script=redeem_script,
            locktime=locktime,
            privkey=privkey,
            preimage=preimage,
            payment_hash=payment_hash,
            prepay_hash=None,
            onchain_amount_sat=onchain_amount_sat,
            lightning_amount_sat=lightning_amount_sat)
        return swap

    async def add_reverse_swap(
        self,
        *,
        redeem_script: bytes,
        locktime: int,  # onchain
        privkey: bytes,
        lightning_amount_sat: int,
        onchain_amount_sat: int,
        preimage: bytes,
        payment_hash: bytes,
        prepay_hash: Optional[bytes] = None,
    ) -> SwapData:
        lockup_address = script_to_p2wsh(redeem_script, net=self.config.network)
        receive_address = self.wallet.get_receiving_address()
        await self.lnwatcher.register_address(lockup_address)
        swap = SwapData(
            redeem_script = redeem_script.hex(),
            locktime = locktime,
            privkey = privkey.hex(),
            preimage = preimage.hex(),
            prepay_hash = bytes_to_hex(prepay_hash),
            lockup_address = lockup_address,
            onchain_amount = onchain_amount_sat,
            receive_address = receive_address,
            lightning_amount = lightning_amount_sat,
            is_reverse = True,
            is_redeemed = False,
            funding_txid = None,
            spending_txid = None,
        )
        if prepay_hash:
            self.prepayments[prepay_hash] = payment_hash
        swap._payment_hash = payment_hash
        self._add_or_reindex_swap(swap)

        self.add_lnwatcher_callback(swap)
        return swap

    def server_add_swap_invoice(self, request):
        invoice = request['invoice']
        invoice = Invoice.from_bech32(invoice)
        key = invoice.rhash
        payment_hash = bytes.fromhex(key)
        assert key in self.swaps
        swap = self.swaps[key]
        assert swap.lightning_amount == int(invoice.get_amount_sat())
        self.lnworker.save_invoice(invoice)
        # check that we have the preimage
        assert sha256(hex_to_bytes(swap.preimage)) == payment_hash
        assert swap.spending_txid is None
        self.invoices_to_pay[key] = 0
        return {}

    def create_funding_tx(
        self,
        *,
        swap: SwapData,
        tx: Optional[PartialTransaction],
        # *,
        # password,
        # batch_rbf: Optional[bool] = None,
    ) -> PartialTransaction:
        # create funding tx
        # note: rbf must not decrease payment
        # this is taken care of in wallet._is_rbf_allowed_to_touch_tx_output
        if tx is None:
            funding_output = PartialTxOutput.from_address_and_value(swap.lockup_address, swap.onchain_amount)
            tx = self.wallet.create_transaction(
                outputs_without_change=[funding_output],
                rbf=True,
            )
        else:
            raise NotImplementedError
        return tx

#     @log_exceptions
    def broadcast_funding_tx(self, swap: SwapData, tx: PartialTransaction) -> None:
        swap.funding_txid = tx.txid()
        self.wallet.broadcast_transaction(tx)

    def _add_or_reindex_swap(self, swap: SwapData) -> None:
        if swap.payment_hash.hex() not in self.swaps:
            self.swaps[swap.payment_hash.hex()] = swap
        if swap._funding_prevout:
            self._swaps_by_funding_outpoint[swap._funding_prevout] = swap
        self._swaps_by_lockup_address[swap.lockup_address] = swap

    def server_update_pairs(self) -> None:
        """ for server """
        self.percentage = float(self.config.swapserver_fee_millionths) / 10000
        self._min_amount = 20000
        self._max_amount = 10000000
        self.normal_fee = self.get_fee(size_vb=CLAIM_FEE_SIZE)
        self.lockup_fee = self.get_fee(size_vb=LOCKUP_FEE_SIZE)
        self.claim_fee = self.get_fee(size_vb=CLAIM_FEE_SIZE)

    def get_max_amount(self):
        return self._max_amount

    def get_min_amount(self):
        return self._min_amount

    def check_invoice_amount(self, x):
        return self.get_min_amount() <= x <= self.get_max_amount()

    def _get_recv_amount(self, send_amount: Optional[int], *, is_reverse: bool) -> Optional[int]:
        """For a given swap direction and amount we send, returns how much we will receive.

        Note: in the reverse direction, the mining fee for the on-chain claim tx is NOT accounted for.
        In the reverse direction, the result matches what the swap server returns as response["onchainAmount"].
        """
        if send_amount is None:
            return
        x = Decimal(send_amount)
        percentage = Decimal(self.percentage)
        if is_reverse:
            if not self.check_invoice_amount(x):
                return
            # see/ref:
            # https://github.com/BoltzExchange/boltz-backend/blob/e7e2d30f42a5bea3665b164feb85f84c64d86658/lib/service/Service.ts#L948
            percentage_fee = math.ceil(percentage * x / 100)
            base_fee = self.lockup_fee
            x -= percentage_fee + base_fee
            x = math.floor(x)
            if x < dust_threshold():
                return
        else:
            x -= self.normal_fee
            percentage_fee = math.ceil(x * percentage / (100 + percentage))
            x -= percentage_fee
            if not self.check_invoice_amount(x):
                return
        x = int(x)
        return x

    def _get_send_amount(self, recv_amount: Optional[int], *, is_reverse: bool) -> Optional[int]:
        """For a given swap direction and amount we want to receive, returns how much we will need to send.

        Note: in the reverse direction, the mining fee for the on-chain claim tx is NOT accounted for.
        In the forward direction, the result matches what the swap server returns as response["expectedAmount"].
        """
        if not recv_amount:
            return
        x = Decimal(recv_amount)
        percentage = Decimal(self.percentage)
        if is_reverse:
            # see/ref:
            # https://github.com/BoltzExchange/boltz-backend/blob/e7e2d30f42a5bea3665b164feb85f84c64d86658/lib/service/Service.ts#L928
            # https://github.com/BoltzExchange/boltz-backend/blob/e7e2d30f42a5bea3665b164feb85f84c64d86658/lib/service/Service.ts#L958
            base_fee = self.lockup_fee
            x += base_fee
            x = math.ceil(x / ((100 - percentage) / 100))
            if not self.check_invoice_amount(x):
                return
        else:
            if not self.check_invoice_amount(x):
                return
            # see/ref:
            # https://github.com/BoltzExchange/boltz-backend/blob/e7e2d30f42a5bea3665b164feb85f84c64d86658/lib/service/Service.ts#L708
            # https://github.com/BoltzExchange/boltz-backend/blob/e7e2d30f42a5bea3665b164feb85f84c64d86658/lib/rates/FeeProvider.ts#L90
            percentage_fee = math.ceil(percentage * x / 100)
            x += percentage_fee + self.normal_fee
        x = int(x)
        return x

    @classmethod
    def sign_tx(cls, tx: PartialTransaction, swap: SwapData) -> None:
        preimage = hex_to_bytes(swap.preimage) if swap.is_reverse else 0
        witness_script = hex_to_bytes(swap.redeem_script)
        txin = tx.inputs()[0]
        assert len(tx.inputs()) == 1, f"expected 1 input for swap claim tx. found {len(tx.inputs())}"
        assert txin.prevout.txid.hex() == swap.funding_txid
        txin.script_sig = b''
        txin.witness_script = witness_script
        sig = tx.sign_txin(0, hex_to_bytes(swap.privkey))
        witness = [sig, preimage, witness_script]
        txin.witness = construct_witness(witness)

    def _create_and_sign_claim_tx(
        self,
        *,
        txin: PartialTxInput,
        swap: SwapData,
    ) -> PartialTransaction:
        # FIXME the mining fee should depend on swap.is_reverse.
        #       the txs are not the same size...
        amount_sat = txin.value_sats() - self.get_fee(size_vb=CLAIM_FEE_SIZE)
        if amount_sat < dust_threshold():
            raise BelowDustLimit()
        if swap.is_reverse:  # successful reverse swap
            locktime = 0
            # preimage will be set in sign_tx
        else:  # timing out forward swap
            locktime = swap.locktime
        tx = create_claim_tx(
            txin=txin,
            witness_script=swap.redeem_script,
            address=swap.receive_address,
            amount_sat=amount_sat,
            locktime=locktime,
        )
        self.sign_tx(tx, swap)
        return tx

    async def server_create_normal_swap(self, request):
        # normal for client, reverse for server
        #request = await r.json()
        lightning_amount_sat = request['invoiceAmount']
        their_pubkey = bytes.fromhex(request['refundPublicKey'])
        assert len(their_pubkey) == 33
        if self.lnworker.num_sats_can_send() < lightning_amount_sat:
            self.logger.warning(f'not enough outgoing capacity to satisfy swap: {self.lnworker.num_sats_can_send()} sat,'
                                f' rejecting swap for {lightning_amount_sat} sat')
            return {'error': 'not enough outgoing capacity'}
        swap = await self.create_reverse_swap(
            lightning_amount_sat=lightning_amount_sat,
            their_pubkey=their_pubkey,
        )
        response = {
            "id": swap.payment_hash.hex(),
            'preimageHash': swap.payment_hash.hex(),
            "acceptZeroConf": False,
            "expectedAmount": swap.onchain_amount,
            "timeoutBlockHeight": swap.locktime,
            "address": swap.lockup_address,
            "redeemScript": swap.redeem_script.hex(),
        }
        return response

    async def server_create_swap(self, request):
        # reverse for client, forward for server
        # requesting a normal swap (old protocol) will raise an exception
        #request = await r.json()
        req_type = request['type']
        assert request['pairId'] == 'BTC/BTC'
        if req_type == 'reversesubmarine':
            lightning_amount_sat=request['invoiceAmount']
            payment_hash=bytes.fromhex(request['preimageHash'])
            their_pubkey=bytes.fromhex(request['claimPublicKey'])
            assert len(payment_hash) == 32
            assert len(their_pubkey) == 33
            if self.lnworker.num_sats_can_receive() < lightning_amount_sat:
                self.logger.warning(f'not enough incoming capacity to receive swap: '
                                    f'{self.lnworker.num_sats_can_receive()}, '
                                    f'rejecting swap for {lightning_amount_sat}sat')
                return {'error': 'not enough incoming capacity, please open channel'}
            if self.wallet.balance_sat() < lightning_amount_sat:
                self.logger.warning(f'not enough onchain balance to satisfy: {self.wallet.balance_sat()} sat'
                                    f', rejecting swap for {lightning_amount_sat} sat')
                return {'error': 'not enough onchain balance'}
            swap, invoice, prepay_invoice = await self.create_normal_swap(
                lightning_amount_sat=lightning_amount_sat,
                payment_hash=payment_hash,
                their_pubkey=their_pubkey
            )
            response = {
                'id': payment_hash.hex(),
                'invoice': invoice,
                'minerFeeInvoice': prepay_invoice,
                'lockupAddress': swap.lockup_address,
                'redeemScript': swap.redeem_script,
                'timeoutBlockHeight': swap.locktime,
                "onchainAmount": swap.onchain_amount,
            }
        elif req_type == 'submarine':
            raise Exception('Deprecated API. Please upgrade your version of Electrum')
        else:
            raise Exception('unsupported request type:' + req_type)
        return response


class NostrTransport:  # (Logger):
    # uses nostr:
    #  - to advertise servers
    #  - for client-server RPCs (using DMs)
    #     (todo: we should use onion messages for that)

    NOSTR_DM = 4
    NOSTR_SWAP_OFFER = 10943
    NOSTR_EVENT_TIMEOUT = 60*60*24
    NOSTR_EVENT_VERSION = 1

    def __init__(self, *, config, sm):
        self.logger = config.logger
        self.config = config
        # self.network = sm.network
        self.relays = config.nostr_relays
        self.sm = sm
        self.offers = {}
        keypair = config.nostr_keypair
        self.private_key = keypair.privkey
        self.nostr_private_key = to_nip19('nsec', keypair.privkey.hex())
        self.nostr_pubkey = keypair.pubkey.hex()[2:]
        self.dm_replies = defaultdict(asyncio.Future)  # type: Dict[bytes, asyncio.Future]
        self.relay_manager = aionostr.Manager(self.relays, private_key=self.nostr_private_key)
        self.is_connected = asyncio.Event()
        self.taskgroup = OldTaskGroup()
        # self.server_relays = None

    def __enter__(self):
        asyncio.create_task(self.main_loop())  # , self.network.asyncio_loop)
        return self

    def __exit__(self, ex_type, ex, tb):
        asyncio.create_task(self.stop())  # , self.network.asyncio_loop)

#     @log_exceptions
    async def main_loop(self):
        assert self.sm.is_server, "This is a CLN plugin and should always run as server"
        self.logger.info(f'starting nostr transport with pubkey: {self.nostr_pubkey}')
        self.logger.info(f'nostr relays: {self.relays}')
        await self.relay_manager.connect()
        self.is_connected.set()
        try:
            async with self.taskgroup as group:
                await group.spawn(self.check_direct_messages())
        except Exception:
            self.logger.error(f"Nostr taskgroup died. {traceback.format_exc()}")
        finally:
            self.logger.info("Nostr taskgroup stopped.")

    async def stop(self):
        self.logger.info("shutting down nostr transport")
        self.sm.is_initialized.clear()
        # trying to gracefully shut down what's left of the NostrTransport
        for coro in [self.relay_manager.close, self.taskgroup.cancel_remaining]:
            try:
                await coro()
            except Exception:
                pass

#     @log_exceptions
    async def publish_offer(self, sm):
        assert self.sm.is_server
        offer = {
            "type": "electrum-swap",
            "version": self.NOSTR_EVENT_VERSION,
            'network': constants.net.NET_NAME,
            'percentage_fee': sm.percentage,
            'normal_mining_fee': sm.normal_fee,
            'reverse_mining_fee': sm.lockup_fee,
            'claim_mining_fee': sm.claim_fee,
            'min_amount': sm._min_amount,
            'max_amount': sm._max_amount,
            'relays': sm.config.nostr_relays_csv,
        }
        self.logger.info(f'publishing swap offer..')
        self.logger.debug(f'offer: {offer}')
        event_id = await aionostr._add_event(
            self.relay_manager,
            kind=self.NOSTR_SWAP_OFFER,
            content=json.dumps(offer),
            private_key=self.nostr_private_key)
        self.logger.debug(f'published swap offer: {event_id}')
        sm.is_initialized.set()

#     @log_exceptions
    async def check_direct_messages(self):
        privkey = aionostr.key.PrivateKey(self.private_key)
        query = {"kinds": [self.NOSTR_DM], "limit":0, "#p": [self.nostr_pubkey]}
        async for event in self.relay_manager.get_events(query, single_event=False, only_stored=False):
            try:
                content = privkey.decrypt_message(event.content, event.pubkey)
                content = json.loads(content)
            except Exception:
                continue
            content['event_id'] = event.id
            content['event_pubkey'] = event.pubkey
            if 'reply_to' in content:
                self.dm_replies[content['reply_to']].set_result(content)
            elif self.sm.is_server and 'method' in content:
                await self.handle_request(content)
            else:
                print('unknown message', content)

    # @log_exceptions
    async def handle_request(self, request):
        assert self.sm.is_server
        # todo: remember event_id of already processed requests
        method = request.pop('method')
        event_id = request.pop('event_id')
        event_pubkey = request.pop('event_pubkey')
        print(f'handle_request: id={event_id} {method} {request}')
        if method == 'addswapinvoice':
            r = self.sm.server_add_swap_invoice(request)
        elif method == 'createswap':
            r = await self.sm.server_create_swap(request)
        elif method == 'createnormalswap':
            r = await self.sm.server_create_normal_swap(request)
        else:
            raise Exception(method)
        r['reply_to'] = event_id
        self.logger.info(f'sending response id={event_id}')
        await self.send_direct_message(event_pubkey, json.dumps(r))


    async def send_direct_message(self, pubkey: str, content: str) -> str:
        event_id = await aionostr._add_event(
            self.relay_manager,
            kind=self.NOSTR_DM,
            content=content,
            private_key=self.nostr_private_key,
            direct_message=pubkey)
        return event_id
